#!perl
use strict;
use warnings FATAL => 'all';
use diagnostics;
use MarpaX::Languages::C::Scan;
use Getopt::Long;
use Pod::Usage;
use POSIX qw/EXIT_FAILURE EXIT_SUCCESS/;
use Config;
use Log::Any qw/$log/;
use Log::Any::Adapter;
use Log::Log4perl qw/:easy/;
use XML::LibXML;

# ABSTRACT: C gibberish <-> English

# VERSION

# PODNAME: cdecl

my $help = 0;
my $out = '';
my $err = '';
my $loglevel = 'WARN';
my $logstderr = 0;

our $CURRENTVERSION;
{
  #
  # Because $VERSION is generated by dzil, not available in dev. tree
  #
  no strict 'vars';
  $CURRENTVERSION = $VERSION;
}

Getopt::Long::Configure("pass_through");
GetOptions ('help!' => \$help,
            'out=s' => \$out,
            'err=s' => \$err,
            'loglevel=s' => \$loglevel,
	    'debug' => sub { $loglevel = 'DEBUG' },
	    'info' => sub { $loglevel = 'INFO' },
	    'warn' => sub { $loglevel = 'WARN' },
	    'error' => sub { $loglevel = 'ERROR' },
	    'fatal' => sub { $loglevel = 'FATAL' },
	    'trace' => sub { $loglevel = 'TRACE' },
	    'Version' => sub { print STDERR "cdecl from MarpaX::Languages::C::AST " . ($CURRENTVERSION || '<undef>') . "\n"; },
            'logstderr!' => \$logstderr);

#
# Do redirection asap, i.e. now, err first, unless help is requested
#
my $saveerr = undef;
my $saveout = undef;

if (! $help) {
    my $saveerr = _redirect(\*STDERR, $err);
    my $saveout = _redirect(\*STDOUT, $out);

    sub END {
        _unredirect(\*STDOUT, $saveout);
        _unredirect(\*STDERR, $saveerr);
    }
}

# ----
# Init 
# ----
my $defaultLog4perlConf = <<DEFAULT_LOG4PERL_CONF;
log4perl.rootLogger              = $loglevel, Screen
log4perl.appender.Screen         = Log::Log4perl::Appender::Screen
log4perl.appender.Screen.stderr  = $logstderr
log4perl.appender.Screen.layout  = PatternLayout
log4perl.appender.Screen.layout.ConversionPattern = %d %-5p %6P %m{chomp}%n
DEFAULT_LOG4PERL_CONF
Log::Log4perl::init(\$defaultLog4perlConf);
Log::Any::Adapter->set('Log4perl');

my $pod = do {local $/; <DATA>};
my $podfh = IO::String->new($pod);
pod2usage(-verbose => 2, -noperldoc => 1, -input => $podfh, -exitval => EXIT_SUCCESS) if ($help);

# -----
# Input
# -----
my $fh;
if (@ARGV) {
    if ($ARGV[0] eq '-') {
        $fh = \*STDIN;
    } else {
        if (! open($fh, '<', $ARGV[0])) {
            print STDERR "Cannot open $ARGV[0], $!\n";
            exit(EXIT_FAILURE);
        }
    }
} else {
    $fh = \*STDIN;
}
my $input = <$fh>;
#
# People might often forget the last semicolon. Add it eventually.
#
if (! ($input =~ /;\s*$/)) {
  $input .= ';'
}

# -------------
# Configuration
# -------------
my %config = ();
$config{start} = 'declaration';
$config{actionObject} = 'MarpaX::Languages::C::Scan::Actions';
$config{nonTerminalSemantic} = ':default ::= action => nonTerminalSemantic';

# -------
# Get DOM
# -------
my $dom = ${MarpaX::Languages::C::AST->new(%config)->parse(\$input)->value()};

# ---------
# Giberrish
# ---------
#
# Special case of of static assert declaration
#
if ($dom->firstChild()->localname() eq 'staticAssertDeclaration') {
    my $constantExpression = $dom->firstChild()->nextSibling()->nextSibling();
    my $stringLiteral = $constantExpression->nextSibling()->nextSibling();
    printf "Static assertion with condition (%s) and message %s\n", _nodeToString($constantExpression, $input), _nodeToString($stringLiteral, $input);
    exit(EXIT_SUCCESS);
}
#
# We are left with:
# declaration ::= declarationSpecifiers SEMICOLON
#                 declarationCheck
#
# declarationCheck ::= declarationCheckdeclarationSpecifiers declarationCheckinitDeclaratorList SEMICOLON
# declarationCheckdeclarationSpecifiers ::= declarationSpecifiers
# declarationCheckinitDeclaratorList    ::= initDeclaratorList
#
my $declarationSpecifiers = undef;
my @declarators = ();
if ($dom->firstChild()->localname() eq 'declarationSpecifiers') {
  $declarationSpecifiers = $dom->firstChild();
} else {
  $declarationSpecifiers = $dom->firstChild()->firstChild()->firstChild();
  my $initDeclaratorList = $dom->firstChild()->firstChild()->nextSibling()->firstChild();
  # initDeclaratorList ::= initDeclarator+ separator => COMMA proper => 1
  my @initDeclarator = $initDeclaratorList->childNodes();
  foreach (@initDeclarator) {
    push(@declarators, $_->firstChild());
  }
}

$log->debugf('Declaration Specifiers: %s', _nodeToString($declarationSpecifiers, $input));
foreach (@declarators) {
  $log->debugf('Declarator: %s', _nodeToString($_, $input));
}

exit(EXIT_SUCCESS);

sub _nodeToString {
    my ($node, $input) = @_;

    my $firstLexeme = XML::LibXML::XPathExpression->new('(.//*[@start])[1]');
    my $lastLexeme = XML::LibXML::XPathExpression->new('(.//*[@start])[last()]');

    my @firstLexemes = $node->findnodes($firstLexeme);
    my @lastLexemes = $node->findnodes($lastLexeme);

    if (@firstLexemes && @lastLexemes) {
        my $startPosition = $firstLexemes[0]->findvalue('./@start');
        my $endPosition = $lastLexemes[0]->findvalue('./@start') + $lastLexemes[0]->findvalue('./@length');
        my $length = $endPosition - $startPosition;
        return substr($input, $startPosition, $length);
    } else {
        return '';
    }
}

sub _redirect {
    my ($fh, $filename) = @_;

    my $savefh = undef;

    if (defined($filename) && "$filename") {
        if (! open($savefh, '>&', $fh)) {
            warn "Cannot save $fh handle, $!";
        } else {
            if (! open($fh, '>', $filename)) {
                warn "Cannot redirect $fh to $filename, $!";
                if (! open($fh, '>&', $savefh)) {
                    warn "Cannot restore $fh, $!";
                }
                $savefh = undef;
            } else {
                #
                # Unbuffer the redirected filehandle
                #
                my $oldfh = select($fh);
                $| = 1;
                select($oldfh);
            }
        }
    }
    return $savefh;
}

sub _unredirect {
    my ($fh, $savefh) = @_;

    if (defined($savefh)) {
        if (! close($fh)) {
            warn "Cannot close $fh";
        }
        #
        # Unredirect anyway
        #
        if (! open($fh, '>&', $savefh)) {
            warn "Cannot restore $fh, $!";
        }
    }
}

__DATA__

# --------------------------------------------------------------------------------------

=head1 NAME

cdecl - C gibberish <-> English

=head1 SYNOPSIS

 cdecl [options] file

 Startup Options:
   --help               This help.
   --out <argument>     Redirect any output to this filename.
   --err <argument>     Redirect any error to this filename.
   --loglevel <level>   A level that has to be meaningful for Log::Log4perl, typically DEBUG, INFO, WARN, ERROR, FATAL or TRACE.
   --logstderr          Logs to stderr or not.
   --Version            print version to stderr and exit.

 Aliased options:
   --debug              Alias to --loglevel DEBUG
   --info               Alias to --loglevel INFO
   --warn               Alias to --loglevel WARN
   --error              Alias to --loglevel ERROR
   --fatal              Alias to --loglevel FATAL
   --trace              Alias to --loglevel TRACE

=head1 OPTIONS

=over 8

=item B<--help>

This help

=item B<--loglevel level>

A level that has to be meaningful for Log::Log4perl, typically DEBUG, INFO, WARN, ERROR, FATAL or TRACE.
Default is WARN.

Note that tracing Marpa library itself is possible, but only using environment variable MARPA_TRACE /and/ saying --loglevel TRACE.

In case of trouble, typical debugging phases c2ast are:
--loglevel INFO
then:
--loglevel DEBUG
then:
--loglevel TRACE

=item B<--debug>

Shortcut for --loglevel DEBUG

=item B<--info>

Shortcut for --loglevel INFO

=item B<--warn>

Shortcut for --loglevel WARN

=item B<--error>

Shortcut for --loglevel ERROR

=item B<--fatal>

Shortcut for --loglevel FATAL

=item B<--trace>

Shortcut for --loglevel TRACE

=item B<--logstderr>

Log to stderr or not. Default is a false value.

=item B<--Version>

Print version and exit.

=back

=head1 NOTES

If argument B<file> is absent or equal to "-", then STDIN is assumed.

=head1 SEE ALSO

L<MarpaX::Languages::C::AST>
