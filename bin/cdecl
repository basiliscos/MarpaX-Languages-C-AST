#!perl
use strict;
use warnings FATAL => 'all';
use diagnostics;
use MarpaX::Languages::C::Scan;
use Getopt::Long;
use Pod::Usage;
use POSIX qw/EXIT_FAILURE EXIT_SUCCESS/;
use Config;
use Log::Any qw/$log/;
use Log::Any::Adapter;
use Log::Log4perl qw/:easy/;
use XML::LibXML;

# ABSTRACT: C gibberish <-> English

# VERSION

# PODNAME: cdecl

my $help = 0;
my $out = '';
my $err = '';
my $input = undef;
my $loglevel = 'WARN';
my $logstderr = 0;

our $CURRENTVERSION;
{
  #
  # Because $VERSION is generated by dzil, not available in dev. tree
  #
  no strict 'vars';
  $CURRENTVERSION = $VERSION;
}

our $firstLexemeXpath = XML::LibXML::XPathExpression->new('(.//*[@start])[1]');
our $lastLexemeXpath = XML::LibXML::XPathExpression->new('(.//*[@start])[last()]');
our $allLexemesXpath = XML::LibXML::XPathExpression->new('(.//*[@start])');
our $alignmentSpecifierXpath = XML::LibXML::XPathExpression->new('.//alignmentSpecifier');
our $notInISOXpath = XML::LibXML::XPathExpression->new('.//msvsAttributeAny|.//gccAsmExpression');

Getopt::Long::Configure("pass_through");
GetOptions ('help!' => \$help,
            'out=s' => \$out,
            'err=s' => \$err,
            'input=s' => \$input,
            'loglevel=s' => \$loglevel,
	    'debug' => sub { $loglevel = 'DEBUG' },
	    'info' => sub { $loglevel = 'INFO' },
	    'warn' => sub { $loglevel = 'WARN' },
	    'error' => sub { $loglevel = 'ERROR' },
	    'fatal' => sub { $loglevel = 'FATAL' },
	    'trace' => sub { $loglevel = 'TRACE' },
	    'Version' => sub { print STDERR "cdecl from MarpaX::Languages::C::AST " . ($CURRENTVERSION || '<undef>') . "\n"; },
            'logstderr!' => \$logstderr);

#
# Do redirection asap, i.e. now, err first, unless help is requested
#
my $saveerr = undef;
my $saveout = undef;

if (! $help) {
    my $saveerr = _redirect(\*STDERR, $err);
    my $saveout = _redirect(\*STDOUT, $out);

    sub END {
        _unredirect(\*STDOUT, $saveout);
        _unredirect(\*STDERR, $saveerr);
    }
}

# ----
# Init 
# ----
my $defaultLog4perlConf = <<DEFAULT_LOG4PERL_CONF;
log4perl.rootLogger              = $loglevel, Screen
log4perl.appender.Screen         = Log::Log4perl::Appender::Screen
log4perl.appender.Screen.stderr  = $logstderr
log4perl.appender.Screen.layout  = PatternLayout
log4perl.appender.Screen.layout.ConversionPattern = %d %-5p %6P %m{chomp}%n
DEFAULT_LOG4PERL_CONF
Log::Log4perl::init(\$defaultLog4perlConf);
Log::Any::Adapter->set('Log4perl');

my $pod = do {local $/; <DATA>};
my $podfh = IO::String->new($pod);
pod2usage(-verbose => 2, -noperldoc => 1, -input => $podfh, -exitval => EXIT_SUCCESS) if ($help);

# -----
# Input
# -----
if (! defined($input)) {
  my $fh;
  if (@ARGV) {
    if ($ARGV[0] eq '-') {
      $fh = \*STDIN;
    } else {
      if (! open($fh, '<', $ARGV[0])) {
	print STDERR "Cannot open $ARGV[0], $!\n";
	exit(EXIT_FAILURE);
      }
    }
  } else {
    $fh = \*STDIN;
  }
  $input = <$fh>;
}
#
# People might often forget the last semicolon. Add it eventually.
#
if (! ($input =~ /;\s*$/)) {
  $log->infof('Semicolon ";" character added to input');
  $input .= ';'
}

# -------------
# Configuration
# -------------
my %config = ();
$config{start} = 'declaration';
$config{actionObject} = 'MarpaX::Languages::C::Scan::Actions';
$config{nonTerminalSemantic} = ':default ::= action => nonTerminalSemantic';

# -------
# Get DOM
# -------
my $dom = ${MarpaX::Languages::C::AST->new(%config)->parse(\$input)->value()};
#
# Because we will modify the DOM, make a copy of it
#
$dom = $dom->cloneNode(1);
#
# Remove any child not stricly part of the standard
#
foreach ($dom->findnodes($notInISOXpath)) {
    my $parent = $_->parentNode();
    #
    # Do not log if this is a node with no child
    #
    if ($_->childNodes()) {
        $log->debugf('Removing node %s: %s', $_->localname(), _nodeToString($_, $input));
    }
    $parent->removeChild($_);
}

# ---------
# Giberrish
# ---------
#
# Special case of of static assert declaration
#
if ($dom->firstChild()->localname() eq 'staticAssertDeclaration') {
    my $constantExpression = $dom->firstChild()->nextSibling()->nextSibling();
    my $stringLiteral = $constantExpression->nextSibling()->nextSibling();
    printf "Static assertion with condition (%s) and message %s\n", _nodeToString($constantExpression, $input), _nodeToString($stringLiteral, $input);
    exit(EXIT_SUCCESS);
}
#
# We are left with:
# declaration ::= declarationSpecifiers SEMICOLON
#                 declarationCheck
#
# declarationCheck ::= declarationCheckdeclarationSpecifiers declarationCheckinitDeclaratorList SEMICOLON
# declarationCheckdeclarationSpecifiers ::= declarationSpecifiers
# declarationCheckinitDeclaratorList    ::= initDeclaratorList
#
my $declarationSpecifiers = undef;
my @declarators = ();
if ($dom->firstChild()->localname() eq 'declarationSpecifiers') {
  $declarationSpecifiers = $dom->firstChild();
} else {
  $declarationSpecifiers = $dom->firstChild()->firstChild()->firstChild();
  my $initDeclaratorList = $dom->firstChild()->firstChild()->nextSibling()->firstChild();
  # initDeclaratorList ::= initDeclarator+ separator => COMMA proper => 1
  my @initDeclarator = $initDeclaratorList->childNodes();
  foreach (@initDeclarator) {
    push(@declarators, $_->firstChild());
  }
}

$log->infof('Declaration Specifiers: %s', _nodeToString($declarationSpecifiers, $input));
foreach (@declarators) {
  $log->infof('Declarator: %s', _nodeToString($_, $input));
}

foreach (0..$#declarators) {
    my @decl = ();
    declaratorToDecl(\@decl, $declarators[$_]);
    print "@decl";
    if ($_ < $#declarators) {
        print ', ';
    } else {
        print "\n";
    }
}

{
    my @decl = ();
    # declarationSpecifiersToDecl(\@decl, $declarationSpecifiers);
}

exit(EXIT_SUCCESS);

sub declaratorToDecl {
    my ($declArrayp, $declarator) = @_;
    #
    # declarator ::= pointer directDeclarator
    #              | directDeclarator
    #              | MSVS___C_ASSERT__ LBRACKET expression RBRACKET
    #
    my $directDeclarator = undef;
    my $firstChild = $declarator->firstChild();
    if ($firstChild->localname() eq 'pointer') {
        unshift(@{$declArrayp}, 'pointer to');
        $directDeclarator = $firstChild->nextSibling();
    } elsif ($firstChild->localname() eq 'directDeclarator') {
        $directDeclarator = $firstChild;
    } else {
        #
        # Ignore MSVS C assertion (not removed when cleaning the DOM)
        #
    }

    if (defined($directDeclarator)) {
        my @directDeclaratorArray = ();
        directDeclaratorToDecl(\@directDeclaratorArray, $directDeclarator);
        unshift(@{$declArrayp}, @directDeclaratorArray);
    }
}

sub directDeclaratorToDecl {
    my ($declArrayp, $directDeclarator) = @_;

    # directDeclarator
    # ::= directDeclaratorIdentifier
    # | LPAREN declarator RPAREN
    # | directDeclarator LBRACKET ... RBRACKET
    # | directDeclarator LPAREN_SCOPE parameterTypeList RPAREN_SCOPE
    # | directDeclarator LPAREN_SCOPE RPAREN_SCOPE
    # | directDeclarator LPAREN_SCOPE identifierList RPAREN_SCOPE

    my $firstChild = $directDeclarator->firstChild();
    if ($firstChild->localname() eq 'directDeclaratorIdentifier') {
        push(@{$declArrayp}, 'declare ' . $firstChild->firstChild()->getAttribute('text') . ' as');
    } elsif ($firstChild->localname() eq 'LPAREN') {
        my $declarator = $firstChild->nextSibling();
        my @declaratorArray = ();
        declaratorToDecl(\@declaratorArray, $declarator);
        #
        # Inner declarator: should be prepended
        #
        unshift(@{$declArrayp}, @declaratorArray);
    } else {
        my @declaratorArray = ();
        directDeclaratorToDecl(\@declaratorArray, $firstChild);
        #
        # Inner declarator: should be prepended
        #
        unshift(@{$declArrayp}, @declaratorArray);
        my $secondChild = $firstChild->nextSibling();
        if ($secondChild->localname() eq 'LBRACKET') {
            my @arraySize = ();
            my $nextChild = $secondChild->nextSibling();
            while (defined($nextChild) && $nextChild->localname() ne 'RBRACKET') {
                push(@arraySize, _nodeToString($nextChild, $input));
                $nextChild = $nextChild->nextSibling();
            }
            if (@arraySize) {
                push(@{$declArrayp}, 'array ' . join('', @arraySize) . ' of');
            } else {
                push(@{$declArrayp}, 'array of');
            }
        } else {
            push(@{$declArrayp}, 'function returning');
        }
    }

}

sub _nodeToString {
    my ($node, $input) = @_;

    my @firstLexemes = $node->findnodes($firstLexemeXpath);
    my @lastLexemes = $node->findnodes($lastLexemeXpath);

    if (@firstLexemes && @lastLexemes) {
        my $startPosition = $firstLexemes[0]->getAttribute('start');
        my $endPosition = $lastLexemes[0]->getAttribute('start') + $lastLexemes[0]->getAttribute('length');
        my $length = $endPosition - $startPosition;
        return substr($input, $startPosition, $length);
    } else {
        return '';
    }
}

sub _redirect {
    my ($fh, $filename) = @_;

    my $savefh = undef;

    if (defined($filename) && "$filename") {
        if (! open($savefh, '>&', $fh)) {
            warn "Cannot save $fh handle, $!";
        } else {
            if (! open($fh, '>', $filename)) {
                warn "Cannot redirect $fh to $filename, $!";
                if (! open($fh, '>&', $savefh)) {
                    warn "Cannot restore $fh, $!";
                }
                $savefh = undef;
            } else {
                #
                # Unbuffer the redirected filehandle
                #
                my $oldfh = select($fh);
                $| = 1;
                select($oldfh);
            }
        }
    }
    return $savefh;
}

sub _unredirect {
    my ($fh, $savefh) = @_;

    if (defined($savefh)) {
        if (! close($fh)) {
            warn "Cannot close $fh";
        }
        #
        # Unredirect anyway
        #
        if (! open($fh, '>&', $savefh)) {
            warn "Cannot restore $fh, $!";
        }
    }
}

__DATA__

# --------------------------------------------------------------------------------------

=head1 NAME

cdecl - C gibberish <-> English

=head1 SYNOPSIS

 cdecl [options] [file]

 Startup Options:
   --help               This help.
   --input <statement>  Statement to parse.
   --out <argument>     Redirect any output to this filename.
   --err <argument>     Redirect any error to this filename.
   --loglevel <level>   A level that has to be meaningful for Log::Log4perl, typically DEBUG, INFO, WARN, ERROR, FATAL or TRACE.
   --logstderr          Logs to stderr or not.
   --Version            print version to stderr and exit.

 Aliased options:
   --debug              Alias to --loglevel DEBUG
   --info               Alias to --loglevel INFO
   --warn               Alias to --loglevel WARN
   --error              Alias to --loglevel ERROR
   --fatal              Alias to --loglevel FATAL
   --trace              Alias to --loglevel TRACE

=head1 OPTIONS

=over 8

=item B<--help>

This help.

=item B<--input>

Statement to parse.

=item B<--loglevel level>

A level that has to be meaningful for Log::Log4perl, typically DEBUG, INFO, WARN, ERROR, FATAL or TRACE.
Default is WARN.

Note that tracing Marpa library itself is possible, but only using environment variable MARPA_TRACE /and/ saying --loglevel TRACE.

In case of trouble, typical debugging phases c2ast are:
--loglevel INFO
then:
--loglevel DEBUG
then:
--loglevel TRACE

=item B<--debug>

Shortcut for --loglevel DEBUG

=item B<--info>

Shortcut for --loglevel INFO

=item B<--warn>

Shortcut for --loglevel WARN

=item B<--error>

Shortcut for --loglevel ERROR

=item B<--fatal>

Shortcut for --loglevel FATAL

=item B<--trace>

Shortcut for --loglevel TRACE

=item B<--logstderr>

Log to stderr or not. Default is a false value.

=item B<--Version>

Print version and exit.

=back

=head1 NOTES

If argument B<input> is not given and argument B<file> is absent or equal to "-", then STDIN is assumed.

=head1 SEE ALSO

L<MarpaX::Languages::C::AST>
